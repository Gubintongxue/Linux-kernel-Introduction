# Linux内核模块简介

 

## 一、摘要

​	这篇文章主要介绍了Linux内核模块的相关概念，以及简单的模块开发过程。

​	主要从模块开发中的常用指令、内核模块程序的结构、模块使用计数以及模块的编译等角度对内核模块进行介绍。

​	在Linux系统开发过程中，以模块的形式开发其重要性不言自明，而在嵌入式设备驱动开发中将驱动程序以模块的形式发布，更是极大地提高了设备使用的灵活性——用户只需要拿到相关驱动模块，再插入到用户的内核中，即可灵活地使用你的设备。

 

## 二、概述

​	Linux内核整体结构已经很庞大，包含了很多的组件，而对于我们工程师而言，有两种方法将需要的功能包含进内核当中。

​	一：将所有的功能都编译进Linux内核。

​	二：将需要的功能编译成模块，在需要的时候动态地添加。



​	上述两种方式优缺点分析：

​	第一种：

​	优点：不会有版本不兼容的问题，不需要进行严格的版本检查

​	缺点：生成的内核会很大；要在现有的内核中添加新的功能，则要编译整个内核

​	第二种：

​	优点：模块本身不编译进内核，从而控制了内核的大小；模块一旦被加载，将和其它的部分	完全一样。

缺点：可能会有内核与模块版本不兼容的问题，导致内核崩溃；会造成内存的利用率比较低。

 

## 三、模块开发常用的指令

​	在内核模块开发的过程中常用的有以下指令。

```
insmod命令：安装模块，不自动解决依赖模块

rmmod命令：卸载模块

lsmod命令：用于显示已载入系统的模块，显示的内容来自于/proc/moudules文件

modprobe命令：装载or卸载内核模块，会自动解决依赖模块;
              modprobe命令用于自动处理可载入模块。
配置文件：/etc/modprobe.conf, /etc/modprobe.d/*.conf
modprobe -v floppy    #无参数默认安装模块，-v显示详细信息
modprobe -r -v floppy #模块闲置不用时，即自动卸载模块。

modinfo命令：显示模块的详细描述信息
modinfo xfs       #显示xfs模块的描述信息
modinfo -n xfs    #显示模块的文件路径
modinfo -p dm_mod #显示模块参数
modinfo -p xfs    #不是左右模块都有参数的
modinfo -a xfs    #作者
modinfo -d xfs    #描述信息
modinfo -l xfs    #license

depmod命令：内核模块依赖关系文件及系统信息映射文件的生成工具
depmod -a      #显示可用模块

dmesg
1）  insmod: 安装模块，使用方法：
		 insmod XXX.ko

2）  rmmod: 将模块从内核中删除，使用方法：
		 rmmod XXX.ko

3）  lsmod: 列表显示所有的内核模块，可以和grep指令结合使用。使用方法：
     lsmod | grep XXX

4）  modprobe: modprobe可载入指定的个别模块，或是载入一组相依赖的模块。
		 modprobe会根据depmod所产生的依赖关系，决定要载入哪些模块。
     若在载入过程中发生错误，在modprobe会卸载整组的模块。
     依赖关系是通过读取 /lib/modules/2.6.xx/modules.dep得到的。
     而该文件是通过depmod 所建立。

5）  modinfo: 查看模块信息。使用方法：
     modinfo XXX.ko

6）  tree –a: 查看当前目录的整个树结构。使用方法：
     tree -a
```



## 四、内核模块程序结构

 

 1）  模块加载函数（一般需要） 

​	在用insmod或modprobe命令加载模块时，该函数被执行。完成模块的初始化工作。

​	Linux内核的模块加载函数一般用__init标识声明，模块加载函数必须以module_init(函数名)的形式被指定。该函数返回整型值，如果执行成功，则返回0，初始化失败时则返回错误编码，Linux内核当中的错误编码是负值，在<linux/errno.h>中定义。



​	在Linux中，标识__init的函数在连接时放在.init.text这个区段，而且在.initcall.init中保留一份函数指针，初始化的时候内核会根据这些指针调用初始化函数，初始化结束后释放这些init区段（包括前两者）。

​	代码清单：



 2）  模块卸载函数（一般需要） 

​	在用rmmod或modprobe命令卸载模块时，该函数被执行。完成与加载相反的工作。

模块的卸载函数和模块加载函数实现相反的功能，主要包括

​	1若模块加载函数注册了XXX，则模块卸载函数注销XXX

​	2若模块加载函数动态分配了内存，则模块卸载函数释放这些内存

​	3若模块加载函数申请了硬件资源，则模块卸载函数释放这些硬件资源

​	4若模块加载函数开启了硬件资源，则模块卸载函数一定要关闭这些资源

​	代码清单：



 3）  模块许可证声明（必须） 

​	如果不声明，则在模块加载时会收到内核被污染的警告，一般应遵循GPL协议。

代码清单：



 4）  模块参数（可选） 

​	模块在被加载时传递给模块的值，本身应该是模块内部的全局变量。

​	示例程序book.c



​	在向内核插入模块的时候可以用以下方式，并且可以在内核日志中看到模块加载以后变量已经有了值。

![img](D:\github\Linux-kernel-Introduction\some introductions\image\1641949772706-81ecafac-e2e5-43be-b969-57dab8d779f5.png)



 5）  模块导出符号（可选） 

使用模块导出符号，方便其它模块依赖于该模块，并使用模块中的变量和函数等。

在Linux2.6的内核中，/proc/kallsyms文件对应着符号表，它记录了符号和符号对应的内存地址。对于模块而言，使用下面的宏可以导出符号。



 6）  模块信息（可选） 

模块信息则是指模块的作者信息等。

 五、模块使用计数 

Linux内核提供了 MOD_INC_USE_COUNT 和 MOD_DEC_USE_COUNT 宏来管理模块使用计数。但是对于内核模块而言，一般不会自己管理使用计数。

 六、模块的编译 

将下面的Makefile文件放在book.c同级的目录下，然后使用#make命令或者#make all命令编译即可生成book.ko模块文件。

对应的Makefile：



 七、使用模块绕开 

如果功能不编译成模块，则无法绕开GPL，编译成模块后公司发布产品则只需要发布模块，而不需要发布源码。为了Linux系统能够支持模块，需要做以下的工作：

1内核编译时选择“可以加载模块”，嵌入式产品一般都不需要卸载模块，则可以不选择“可卸载模块”

2将我们的ko文件放在文件系统中

3Linux系统实现了insmod、rmmod等工具

4使用时可以用insmod手动加载模块，也可以修改/etc/init.d/rcS文件，从而在系统启动的时候就加载模块。

 八、总结 

本文主要介绍内核模块的概念和基本编程方法，内核模块主要由加载、卸载函数功能函数等一系列声明组成。它可以被传入参数，也可以导出符号，供其它的模块使用。